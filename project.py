# библиотека os для взаимодействия с файловой системой
import os
# библиотека shelve для сохранения объектов в файл
import shelve
# функция floor из библиотеки math для округления числа в меньшую сторону
from math import floor
# библиотека tkinter c псевдонимом tk и библиотека tkinter.ttk с псевдонимом ttk для создания графического интерфейса
import tkinter as tk
import tkinter.ttk as ttk
# функция shuffle из библиотеки random для перемешивания элементов списка
from random import shuffle

# библиотека numpy с псевдонимом np для действий с матрицами
import numpy as np
# функция expit из библиотеки scipy.special для вычисления функции сигмоиды
from scipy.special import expit
# класс Image из библиотеки PIL для обработки изображений
from PIL import Image


class NeuralNet:

    '''Класс NeuralNet представляет объект нейронной сети.

    Целью работы нейронной сети является распознавание рукописной цифры.

    Нейронная сеть состоит из:

    — входного слоя, состоящего из 400 нейронов, что соответствует количеству точек в изображении с разрешением 20*20;
    — выходного слоя, состоящего из 10 нейронов, что соответствует количеству возможных вариантов ответов;
    — нескольких скрытых слоев, количество нейронов в которых может варьироваться.

    Нейрон является простейшей составляющей нейросети, который суммирует поступающий сигнал от каждого нейрона предыдущего уровня,
    применяет к результату функцию активации (сигмоиду), подавляющую слабый сигнал и пропускающую сильный,
    и передает результат на каждый нейрон следующего уровня.

    '''

    def __init__(self, structure=[400, 200, 10], learn_rate=0.2, epochs=2):

        '''Инициализация входных значений и создание атрибутов класса.

        При создании экземпляра класса могут быть указаны следующие параметры:

        — структура нейросети, по умолчанию нейросеть имеет три слоя по 400, 200 и 10 нейронов в каждом соответственно;
        — коэффицент скорости обучения нейросети, по умолчанию равен 0.2;
        — количество эпох - повторений циклов обучения, по умолчанию равен 2.

        '''

        # структура нейросети — количество узлов
        self.structure = structure
        # коэффицент скорости обучения нейронной сети
        self.learn_rate = learn_rate
        # количество эпох — повторений обучения на одинаковом наборе данных
        self.epochs = epochs
        # протяженность нейронной сети, количество слоев
        self.length = len(self.structure)
        # матрица выходных значений на каждом слое
        self.layers = [0 for i in range(self.length)]
        # матрица ошибок между слоями
        self.errors = [0 for i in range(self.length-1)]
        # матрица весовых коэффицентов между слоями
        self.weights = [0 for i in range(self.length-1)]
        # заполнение случайными числами от -0,5 до 0,5
        for i in range(self.length-1):
            self.weights[i] = np.random.rand(self.structure[i+1], self.structure[i])
            self.weights[i] -= 0.5

        # путь к папке с файлами, содержащими весовые коэффиценты
        self.weights_dir = 'w'
        # путь к файлам, содержащим весовые коэффиценты
        self.weights_files = r'w\w'

        # запуск работы нейросети
        self.run()

    def get_weights(self):

        '''Чтение весовых коэффициентов нейросети из файла.

        Функция использует библиотеку shelve для десериализации объектов (преобразования последовательности байтов в объект)
        и чтения их из файла под заданными строковыми ключами.

        В файлах библиотеки shelve w.bak, we.dat, w.dir, записаны следующие объекты:

        — структура нейросети с ключом 'structure';
        — матрица весовых коэффицентов обученной нейросети с ключом 'weights'.

        Если весовые коэффиценты были получены из файла (для этого структуры нейросетей должны быть одинаковыми),
        функция возвращает значение True, иначе — False.

        '''

        # если файл с весовыми коэффицентами отсутствует
        if len(os.listdir(self.weights_dir)) == 0 :
            # выход из функции и возврат значения False
            return False

        # если файл с весовыми коэффицентами пуст
        if os.path.getsize(self.weights_files + '.dat') == 0:
            # выход из функции и возврат значения False
            return False

        # открытие файла с весовыми коэффицентами на чтение
        db = shelve.open(self.weights_files, flag='r')
        # если структура нейросети из файла совпадает с данной
        if self.structure == db['structure']:
            # получение данных весовых коэффицентов
            self.weights = db['weights']
            # закрытие файла
            db.close()
            # выход из функции и возврат значения True
            return True

        # закрытие файла
        db.close()
        # выход из функции и возврат значения False
        return False

    def set_weights(self):

        '''Запись весовых коэффициентов нейросети в файл.

        Функция использует библиотеку shelve для сериализации объектов (представления в виде последовательности байтов)
        и записи их в файл под заданными строковыми ключами.

        Модуль shelve создает в папке w файлы w.bak, w.dat, w.dir.

        '''

        # открытие файла с весовыми коэффицентами на чтение и запись
        db = shelve.open(self.weights_files, flag='n')

        # запись в файл информации о структуре с ключом 'structure'
        db['structure'] = self.structure
        # запись в файл весовых коэффицентов с ключом 'weights'
        db['weights'] = self.weights
        # закрытие файла
        db.close()

    def run(self):

        '''Запуск чтения данных или обучения.

        Функция вызывает метод get_weights(),
        который пытается получить готовые весовые коэффиценты обученной нейросети.

        Если этого не происходит, функция перебирает изображения рукописных цифр и вызывает метод learn(),
        который принимает в качестве параметра список пикселей каждого изображения.

        Полученные весовые коэффиценты записываются в файл вызовом метода set_weights().

        '''

        # если данные нейросети получены из файла
        if self.get_weights():
            # выход из функции
            return

        # иначе, если данные нейросети не были получены из файла, начинается обучение нейросети
        # повторение циклов обучения
        for epoch in range(self.epochs):
            # создание списка путей к изображениям
            img_paths = []
            # перебор цифр от 0 до 9
            for digit in range(10):
                # перебор номеров изображений от 0 до 149
                for i in range(150):
                    # добавление пути в список
                    img_paths.append('images/{}/{}.png'.format(digit, i))
            # перемешивание списка путей к изображениям
            shuffle(img_paths)

            # пока список путей к изображениям не пуст
            while img_paths:
                # получения пути первого изображения и удаление его из списка
                current_img_path = img_paths.pop(0)
                # создания класса Image, представляющего объект изображения
                img = Image.open(current_img_path)
                # получение одномерного списка пикселей
                pixels = np.array(img).ravel()
                # приведение к формату, где 0 соответсвует белому цвету
                pixels = 255 - pixels
                
                # изображенная цифра, которую необходимо распознать
                target = int(current_img_path.split('/')[1])
                # вызов метода learn
                self.learn(pixels, target)

        # запись данных нейросети в файл
        self.set_weights()

    def learn(self, inputs, marker):

        '''Обучение нейронной сети.

        Функция принимает в качестве аргумента список пикселей и изображенную цифру.

        Список из 400 точек представляется в виде двумерного массива, который нейросеть получает на первом слое.

        Например:
        [[Точка 0], [Точка 1], [Точка 2] ... [Точка 398], [Точка 399]]

        Списком целевых значений является двумерный массив, который нейросеть должна получить на выходном слое,
        на него опирается обучение нейросети.
        Он состоит из 10 элементов, где элемент с индексом, соответствующим
        правильному ответу, равен 0.99, а остальные элементы — 0.01.

        Пример списка целевых значений с правильным ответом, равным 2:
        [[0.01], [0.01], [0.99], [0.01], [0.01], [0.01], [0.01], [0.01], [0.01], [0.01]]

        На первом этапе обучения рассчитываются выходные сигналы для каждого слоя нейросети:

        — путем матричного умножения матрицы весовых коэффицентов,
        имеющей размер (длина следующего слоя) * (длина текущего слоя), и матрицы выходных сигналов предыдущего слоя;
        — к полученной матрице применяется функция активации.

        На втором этапе обучения рассчитывается матрица ошибок:

        — На последнем слое она представляет собой разность между целевыми и полученными значениями;
        — На остальных слоях она представляет собой результат матричного умножения матрицы весовых коэффицентов и матрицы ошибок следующего слоя,
        потому что бóльший вклад в величину ошибки делают бóльший весовой коэффицент,
        таким образом величина ошибки равномерно распределяется между бóльшими и меньшими весовыми коэффицентами.

        На третьем этапе обучения весовые коэффиценты корректируются.

        '''

        # нормализация входных данных к диапазону от 0.01 до 1.0
        inputs = inputs / 255.0 * 0.99 + 0.01

        # целевые данные представляются в виде списка нулей
        targets = np.zeros(self.structure[-1])
        # все целевые значения увеличиваются на 0.01
        targets += 0.01
        # целевое значение с правильным ответом равно 0.99
        targets[marker] = 0.99

        # преобразование входных и целевых значений в транспонированный двумерный массив
        inputs = np.array(inputs, ndmin=2).T
        targets = np.array(targets, ndmin=2).T

        # расчет работы каждого слоя
        self.layers[0] = inputs
        # перебор слоев нейросети, начиная со второго
        for i in range(1, self.length):
            # умножение матрицы весовых коэффицентов и матрицы предыдущего слоя
            layer = np.dot(self.weights[i-1], self.layers[i-1])
            # применение функции активации
            self.layers[i] = expit(layer)

        # расчет ошибок между слоями
        self.errors[-1] = targets - self.layers[-1]
        # перебор матриц ошибок от последнего слоя к первому
        for i in range(-2, -(self.length), -1):
            # умножение матрицы весовых коэффицентов и матрицы ошибок предыдущего слоя
            self.errors[i] = np.dot(self.weights[i+1].T, self.errors[i+1])

        # перебор матриц весовых коэффицентов
        for i in range(-1, -(self.length), -1):
            # рассчет поправки в весовые коэффициенты
            wei = np.dot(self.errors[i] * self.layers[i] * (1 - self.layers[i]), np.transpose(self.layers[i-1]))
            # обновление весов между слоями
            self.weights[i] += self.learn_rate * wei

    def poll(self, inputs):

        '''Вычисление результата работы обученной нейронной сети.

        Функция принимает в качестве параметра список пикселей.

        Список из 400 точек представляется в виде двумерного массива, который нейросеть получает на первом слое.

        Путем матричного умножения на каждом слое матрицы весовых коэффицентов и матрицы выходных сигналов предыдущего слоя
        и применения к ним функции активации на выходном слое получается матрица из 10 элементов,
        где индекс наибольшего элемента является правильным ответом.

        '''

        # нормализация входных данных к диапазону от 0.01 до 1.0
        inputs = inputs / 5.0 * 0.99 + 0.01
        # преобразование массива входных значение в двумерный массив
        inputs = np.array(inputs, ndmin=2).T

        # вычисление результата работы
        # первый слой равен входным значениям
        self.layers[0] = inputs
        # перебор слоев нейросети, начиная с первого
        for i in range(1, self.length):
            # умножение матрицы весовых коэффицентов и матрицы предыдущего слоя
            layer = np.dot(self.weights[i-1], self.layers[i-1])
            # применение функции активации
            self.layers[i] = expit(layer)

        # ответом нейросети является индекс наибольшего элемента
        output = np.argmax(self.layers[-1])
        
        # выход из функции и возврат значения переменной output и последнего слоя
        return output, self.layers[-1]


class Application(tk.Frame):

    '''Класс Application представляет объект оконного приложения.

    Класс использует для создания оконного приложения встроенные модули Python —
    tkinter и tkinter.ttk, и наследуется от класса tkinter.Frame, представляющим собой компонент контейнера.

    Главным элементом оконного приложения является поле ввода,
    где, зажав CTRL и водя мышью, можно имитировать рукописное начертание цифр.

    Класс также создает объект нейросети NeuralNet, которая дает ответ, какая цифра написана.

    '''

    def __init__(self, root):

        '''Инициализация входных значений.

        При создании экземпляра класса передается ссылка на окно, в котором будет размещаться текущий контейнер.

        '''

        # ссылка на окно передается методу __init__() родительского класса
        super().__init__(root)

        # развернутое состояние окна
        root.state('zoomed')
        # окно выводится без заголовка и рамки
        root.overrideredirect(True)

        # цвет фона
        self.bg_color = 'DarkGray'
        # указание цвета фона у окна
        root.config(bg=self.bg_color)

        # вывод окна
        self.pack()

        # ширина окна в пикселях
        self.width = int(self.winfo_screenwidth())
        # высота окна в пикселях
        self.height = int(self.winfo_screenheight())
        # отступы между компонентами и границами окна
        self.padding = floor((self.width - self.height * 0.8) / 6)

        # вызов метода create_input_field(), создающего поле ввода
        self.create_input_field()
        # вызов метода create_title(), создающего заголовок
        self.create_title()
        # вызов метода create_result_btn(), создающего кнопку для получения результата
        self.create_result_btn()
        # вызов метода create_result_label(), создающего надпись, отображающую результат
        self.create_result_label()
        # вызов метода create_clear_btn(), создающего кнопку для очистки поля ввода
        self.create_clear_btn()
        # вызов метода create_correctness_labels(), создающего надписи, отображающие вероятность каждого результата
        self.create_correctness_labels()
        # вызов метода create_exit_btn(), создающего кнопку для завершения программы
        self.create_exit_btn()

        # создание экземпляра класса NeuralNet
        self.neural_net = NeuralNet()

    def create_input_field(self):

        '''Функция создает и размещает поле ввода.

        Создается и размещается поле ввода, имеющее 20 точек в ширину и высоту.
        Для этого создается матрица точек, представляющих собой экземпляры класса Dot, описываемого далее.
        Таким образом, все точки не являются копией одного объекта и могут иметь разные значения атрибутов.

        '''

        # получение ширины точки в пикселях
        # ширина поля ввода равна 80% высоты окна
        # ширина точки равна ширине поля ввода, деленной на 20
        dot_width = floor(self.height * 0.8 / 20)

        # создание матрицы 20 × 20 точек — экземпляров класса Dot
        self.dots = [[Dot(dot_width, x, y, self) for x in range(20)]
                                                 for y in range(20)]

        # текущая координата размещения точки по X
        dot_x_pos = self.padding
        # текущая координата размещения точки по Y
        dot_y_pos = floor(0.12 * self.height)

        # перебор рядов точек
        for y in range(20):
            # перебор каждой отдельной точки
            for x in range(20):
                # размещение точки
                self.dots[y][x].place(x=dot_x_pos,                  # координата X
                                      y=dot_y_pos,                  # координата Y
                                      width=dot_width,              # ширина точки
                                      height=dot_width)             # высота точки
                # координата точки по X увеличивается на его ширину
                dot_x_pos += dot_width

            # обнуление координаты точки по X
            dot_x_pos = self.padding
            # координата точки по Y увеличивается на его ширину
            dot_y_pos += dot_width

    def create_title(self):

        '''Функция создает текстовую метку с заголовком.'''

        # создание текстовой метки
        self.title_label = tk.Label()

        # позиция по X
        x_pos = floor(self.padding * 0.5)

        # ширина кнопки
        label_width = self.width - self.padding
        # размер шрифта текста
        font_size = floor(self.height * 0.06 * 0.45)

        # текст метки
        self.title_label['text'] = 'Нейронная сеть, распознающая рукописные цифры'
        # шрифт текста
        self.title_label['font'] = 'Candara {} bold'.format(font_size)
        # цвет фона
        self.title_label['background'] = 'DimGray'
        # цвет текста
        self.title_label['foreground'] = 'White'

        # размещение текстовой метки
        self.title_label.place(x=x_pos,                             # координата X
                               rely=0.03,                           # координата Y
                               width=label_width,                   # ширина текстовой метки
                               relheight=0.06)                      # высота текстовой метки

    def create_result_btn(self):

        '''Функция создает и размещает кнопку для получения результата. Нажатие на кнопку вызывает метод get_result().'''

        # создание кнопки, отвечающей за получение результата
        result_btn = tk.Button()

        # позиция по X
        x_pos = self.padding * 2 + self.height * 0.8

        # ширина кнопки
        btn_width = self.padding * 3
        # размер шрифта текста на кнопке
        font_size = floor(self.height * 0.1 * 0.25)

        # текст кнопки
        result_btn['text'] = 'Результат:'
        # ширина границы кнопки
        result_btn['bd'] = 0
        # шрифт текста
        result_btn['font'] = 'Verdana {} bold'.format(font_size)
        # цвет фона
        result_btn['background'] = 'FireBrick'
        # цвет текста
        result_btn['foreground'] = 'White'
        # цвет фона при нажатии
        result_btn['activebackground'] = 'Maroon'
        # цвет текста при нажатии
        result_btn['activeforeground'] = 'White'

        # привязка функции к событию нажатия кнопки
        result_btn['command'] = self.get_result

        # размещение кнопки
        result_btn.place(x=x_pos,                                   # координата X
                         rely=0.25,                                 # координата Y
                         width=btn_width,                           # ширина кнопки
                         relheight=0.1)                             # высота кнопки

    def get_result(self):

        '''Функция передает список точек объекту нейросети и получает ответ.

        Функция построчно перебирает массив точек self.dots, собирает запись изображения из атрибутов current_color,
        передает ее методу poll объекта нейросети и принимает ответ.

        '''

        # запись изображения, изначально пустая
        pixels = []

        # перебор рядов точек
        for y in range(20):
            # перебор каждой отдельной точки
            for x in range(20):
                # добавление информации о каждой точке через пробел
                pixels.append(self.dots[y][x].current_color)

        # если значений всех точек равны
        if len(set(pixels)) == 1:
            # очистка текстовой метки
            self.result_label['text'] = ''            
            # выход из функции
            return

        # получение ответа нейросети в переменную output и данных последнего слоя в переменную report
        output, report = self.neural_net.poll(np.array(pixels))

        # перебор элементов массива report
        for i in range(len(report)):
            # округление до 3 знаков после запятой
            report[i] = round(report[i][0], 3)

        # отображение ответа в текстовой метке
        self.result_label['text'] = str(output)

        # перебор элементов массива correct_label
        for i in range(10):
            # отображение данных последнего слоя нейросети на текстовой метке
            self.correct_label[i].update_text(report[i][0])

    def create_result_label(self):

        '''Функция создает и размещает текстовую метку, отображающую результат.'''

        # создание текстовой метки
        self.result_label = tk.Label()

        # позиция по X
        x_pos = self.padding * 2.25 + self.height * 0.8

        # ширина кнопки
        label_width = floor(self.padding * 2.5)
        # размер шрифта
        font_size = floor(self.height * 0.3)

        # текст метки
        self.result_label['text'] = ''
        # шрифт текста
        self.result_label['font'] = 'Times-New-Roman {} bold'.format(font_size)
        # цвет фона
        self.result_label['background'] = self.bg_color

        # размещение текстовой метки
        self.result_label.place(x=x_pos,                            # координата X
                                rely=0.4,                           # координата Y
                                width=label_width,                  # ширина текстовой метки
                                relheight=0.3)                      # высота текстовой метки

    def create_clear_btn(self):

        '''Функция создает и размещает кнопку для очистки поля ввода. Нажатие на кнопку вызывает метод clear().'''

        # создание кнопки, отвечающей за очистку поля ввода
        clear_btn = tk.Button()
        # позиция по X
        x_pos = self.padding * 2.25 + self.height * 0.8
        # позиция по Y
        y_pos = self.height * 0.75

        # ширина кнопки
        btn_width = self.padding * 2.5
        # размер шрифта текста на кнопке
        font_size = floor(self.height * 0.07 * 0.2)

        # текст кнопки
        clear_btn['text'] = 'Очистить\nполе ввода'
        # ширина границы кнопки
        clear_btn['bd'] = 0
        # шрифт текста
        clear_btn['font'] = 'Verdana {} bold'.format(font_size)
        # цвет фона
        clear_btn['background'] = 'DimGray'
        # цвет текста
        clear_btn['foreground'] = 'White'
        # цвет фона при нажатии
        clear_btn['activebackground'] = 'Maroon'
        # цвет текста при нажатии
        clear_btn['activeforeground'] = 'White'

        # привязка функции к событию нажатия кнопки
        clear_btn['command'] = self.clear

        # размещение кнопки
        clear_btn.place(x=x_pos,                                    # координата X
                        rely=0.75,                                  # координата Y
                        width=btn_width,                            # ширина кнопки
                        relheight=0.07)                             # высота кнопки

    def create_correctness_labels(self):

        '''Функция создает и размещает 10 текстовых меток с данными о последнем слое нейросети,
        то есть вероятности, что написана цифра, указанная на этой метке.'''

        # ширина текстовой метки в пикселях
        label_width = floor((self.width - self.padding) * 0.08)
        # высота текстовой метки в пикселях
        label_height = floor(self.height * 0.045)

        # отступы между текстовыми метками в пикселях
        label_padding = floor((self.width - self.padding) * 0.022)
        # размер шрифта
        font_size = floor(label_height * 0.4)

        # массив экземпляров класса CorrectnessLabel, которому передаются порядковый номер, ширина, высота и размер шрифта
        self.correct_label = [CorrectnessLabel(i, label_width, label_height, font_size) for i in range(10)]

        # текущая позиция по X
        x_pos = floor(self.padding * 0.5)

        # перебор элементов массива correct_label 
        for i in range(10):
            # размещение текстовой метки
            self.correct_label[i].place(x=x_pos,                    # координата X
                                        rely=0.9375,                # координата Y
                                        width=label_width,          # ширина текстовой метки
                                        height=label_height)        # высота текстовой метки
            # текущая позиция по X увеличивается на ширину текстовой метки и отступ между ними
            x_pos += label_width + label_padding

    def create_exit_btn(self):

        '''Функция создает и размещает кнопку, отвечающую за завершение программы.'''

        # создание кнопки, отвечающей за завершение работы программы
        exit_btn = tk.Button()

        # размер шрифта текста на кнопке
        font_size = floor(self.height * 0.03 * 0.7)

        # текст кнопки
        exit_btn['text'] = '×'
        # ширина границы кнопки
        exit_btn['bd'] = 0
        # шрифт текста
        exit_btn['font'] = 'Arial {} bold'.format(font_size)
        # цвет фона
        exit_btn['background'] = self.bg_color
        # цвет текста
        exit_btn['foreground'] = 'Black'
        # цвет фона при нажатии
        exit_btn['activebackground'] = 'Red'
        # цвет текста при нажатии
        exit_btn['activeforeground'] = 'White'

        # привязка функции к событию нажатия кнопки
        exit_btn['command'] = lambda: exit()

        # размещение кнопки
        exit_btn.place(relx=0.97,                                   # координата X
                       rely=0,                                      # координата Y
                       relwidth=0.03,                               # ширина кнопки
                       relheight=0.03)                              # высота кнопки

    def dyeing(self, x_pos, y_pos, level):

        '''Функция окрашивает указанную точку.

        У точки, находящейся в матрице точек по координатам x_pos и y_pos, вызывается метод set_color,
        принимающий в качестве аргумента величину level, на которую изменится цвет.

        '''

        # вызов у точки метода set_color с аргументом level
        self.dots[y_pos][x_pos].set_color(level)

    def clear(self):

        '''Функция очищает поле ввода.

        Функция перебирает все точки и вызывает у них метод set_color, который принимает в качестве аргумента -5,
        то есть точке задается самый светлый цвет — белый. Кроме того, очищается текстовые метки с результатом и данными последенего слоя нейросети.

        '''

        # перебор рядов точек
        for y in range(20):
            # перебор каждой отдельной точки
            for x in range(20):
                # вызов у точки метода set_color с аргументом -5
                self.dots[y][x].set_color(-5)

        # очистка текстовой метки c результатом
        self.result_label['text'] = ''

        # перебор элементов массива correct_label
        for i in range(10):
            # очистка текстовой метки с вероятностью результата
            self.correct_label[i].clear_text()


class CorrectnessLabel(tk.Label):
    
    '''Класс CorrectnessLabel представляет объект текстовой метки.
    
    Класс наследуется от класса tkinter.Label, представляющего компонент текстовой метки.

    На текстовой метке отображается вероятность, что написана цифра, соответсвующая атрибуту number,
    полученная в результате работы нейросети на последнем слое, от 0 до 0.99.

    '''

    def __init__(self, number, width, height, font_size):

        '''Инициализация входных значений.

        При создании экземпляра класса передается порядковый номер, ширина и высота текстовой метки в пикселях, размер шрифта.

        '''

        # инициализация родительского класса
        super().__init__()

        # создание атрибутов класса
        # порядковый номер
        self.number = number
        # содержимое текстовой метки
        self.text = '{}: 0'.format(self.number)

        # задание параметров текстовой метки
        self.config(width=width,                                    # ширина текстовой метки
                    height=height,                                  # высота текстовой метки
                    background='Silver',                            # цвет фона
                    foreground = 'Black',                           # цвет текста
                    underline=0,                                    # подчеркивание первого символа
                    font='Sitka {} bold'.format(font_size),         # шрифт
                    text=self.text)                                 # текстовое содержание


    def update_text(self, correct_value):

        '''Функция обновляет содержимое текстовой метки.'''

        # содержимое текстовой метки
        self.text = '{}: {}'.format(self.number, correct_value)
        # задание параметра text
        self.config(text=self.text)

    def clear_text(self):

        '''Функция очищает содержимое текстовой метки.'''

        # содержимое текстовой метки
        self.text = '{}: 0'.format(self.number)
        # задание параметра text
        self.config(text=self.text)


class Dot(tk.Button):

    '''Класс Dot представляет объект точки, из которых состоит поле ввода.

    Класс наследуется от класса tkinter.Button, представляющего компонент кнопки.

    Каждая точка определяет соседние точки, которые будут закрашиваться параллельно с ним, но более светлым цветом.

    В переменной first_neighbors хранится список координат соседних точек первого порядка — находящихся сверху, снизу, слева и справа.

    В переменной second_neighbors хранится список координат соседних точек второго порядка —
    находящихся сверху справа, сверху слева, снизу справа и снизу слева.

    К точке привязывается событие, вызываемое при одновременном удержании CTRL и наведении курсора мыши,
    в результате которого закрашивается точка, у которой произошло событие и соседние с ней точки.

    '''

    def __init__(self, width, x_pos, y_pos, parent):

        '''Инициализация входных значений.

        При создании экземпляра класса передается ширина точки в пикселях, номер столбца, номер строки,
        где размещается точка, и ссылка на родительское окно.

        '''

        # инициализация родительского класса
        super().__init__()

        # задание параметров точки
        self.config(width=width,                                    # ширина точки
                    height=width,                                   # высота точки (равна ширине)
                    bg='White',                                     # исходный цвет фона
                    state='disabled',                               # отключение возможности нажатия
                    bd=1,                                           # толщина границы
                    cursor='target')                                # форма курсора при наведении

        # создание атрибутов класса, эквивалентных входным параметрам
        # номер столбца и строки
        self.x_pos, self.y_pos = x_pos, y_pos
        # ссылка на родительское окно
        self.parent = parent

        # список соседних точек первого и второго порядка
        self.first_neighbors = []
        # список соседних точек второго порядка
        self.second_neighbors = []
        # вызов метода set_neighbors, определяющего соседние точки
        self.set_neighbors()

        # возможные цвета точки от белого к черному
        self.colors_list = ['White', 'Gainsboro', 'DarkGray', 'Gray', 'DimGray', 'Black']
        # номер текущего цвета точки
        self.current_color = 0

        # привязка метода dyeing к событию зажатия клавиши CTRL и наведении курсора
        self.bind('<Control-Enter>', self.dyeing)

    def set_neighbors(self):

        '''Функция составляет списки соседних точек.'''

        # временный список соседних точек первого порядка,
        # включающий лишние, отрицательные значения
        fn = []
        # соседняя точка справа
        fn.append((self.x_pos + 1, self.y_pos))
        # соседняя точка слева
        fn.append((self.x_pos - 1, self.y_pos))
        # соседняя точка сверху
        fn.append((self.x_pos, self.y_pos + 1))
        # соседняя точка снизу
        fn.append((self.x_pos, self.y_pos - 1))

        # удаление лишних, отрицательных значений
        # перебор координат соседних точек первого порядка
        for x, y in fn:
            # если координаты находятся в корректном диапазоне
            if 0 <= x <= 19 and 0 <= y <= 19:
                # добавление координат в переменную first_neighbors
                self.first_neighbors.append((x, y))
        # удаление временного списка
        del fn

        # временный список соседних точек второго порядка,
        # включающий лишние, отрицательные значения
        sn = []
        # соседняя точка справа сверху
        sn.append((self.x_pos + 1, self.y_pos + 1))
        # соседняя точка справа снизу
        sn.append((self.x_pos + 1, self.y_pos - 1))
        # соседняя точка слева снизу
        sn.append((self.x_pos - 1, self.y_pos - 1))
        # соседняя точка слева сверху
        sn.append((self.x_pos - 1, self.y_pos + 1))

        # удаление лишних, отрицательных значений
        # перебор координат соседних точек второго порядка
        for x, y in sn:
            # если координаты находятся в корректном диапазоне
            if 0 <= x <= 19 and 0 <= y <= 19:
                # добавление координат в переменную second_neighbors
                self.second_neighbors.append((x, y))
        # удаление временного списка
        del sn

    def set_color(self, level):

        '''Функция окрашивает точку.

        Функция принимает в качестве параметра значение level, содержащее уровень, на который окрасится точка.

        Значение level складывается со значением текущего цвета.
        При выходе из диапазона от 0 до 5, значение текущего цвета приводится к нему.

        Затем у точки изменяется параметр bg (цвет) на номер текущего цвета.

        '''

        # значение текущего цвета увеличивается на значение level
        self.current_color += level

        # если значение текущего цвета больше 5
        if self.current_color > 5:
            # значение текущего цвета устанавливается равным 5
            self.current_color = 5

        # если значение текущего цвета меньше 0
        elif self.current_color < 0:
            # значение текущего цвета устанавливается равным 0
            self.current_color = 0

        # изменение цвета точки
        self.config(bg=self.colors_list[self.current_color])

    def dyeing(self, event):

        '''Функция окрашивает данную и соседние точки.

        Сначала окрашивается данная точка в черный цвет.

        Затем для закрашивания соседних точек у родительского окна вызывается метод dyeing.
        Таким образом, родительское окно является связующим звеном между соседними точками.

        Соседние точки первого уровня окрашиваются на 2 уровня, второго — на 1.

        '''

        # вызов метода set_color c параметром level, равным 5
        self.set_color(level=5)

        # перебор координат соседних точек первого порядка
        for fn_x, fn_y in self.first_neighbors:
            # вызов метода dyeing у родительского окна
            self.parent.dyeing(x_pos=fn_x,                          # номер столбца
                               y_pos=fn_y,                          # номер строки
                               level=2)                             # уровень окрашивания

        # перебор координат соседних точек второго порядка
        for sn_x, sn_y in self.second_neighbors:
            # вызов метода dyeing у родительского окна
            self.parent.dyeing(x_pos=sn_x,                          # номер столбца
                               y_pos=sn_y,                          # номер строки
                               level=1)                             # уровень окрашивания


# создание главного окна — экземпляра класса Tk библиотеки tkinter
root = tk.Tk()
# создание экземпляра класса Application
app = Application(root)
# запуск главного окна
root.mainloop()
